<h1> 全栈的自我修养: 0004 Java 包扫描实现和应用(File篇) </h1>

> I may not be able to change the past, but I can learn from it.<br>
> 我也许不能改变过去发生的事情，但能向过去学习。<br>

@[TOC]

如果你曾经使用过 `Spring`, 那你已经配过 包扫描路径吧，那包扫描是怎么实现的呢？让我们自己写个包扫描


# 用途
基于`Java` 的反射机制，我们很容易根据 `class` 去创建一个实例对象，但如果我们根本不知道某个包下有多少对象时，我们应该怎么做呢？

在使用`Spring`框架时，会根据包扫描路径来找到所有的 `class`, 并将其实例化后存入容器中。

在我们的项目中也会遇到这样的场景，比如某个包为 `org.example.plugins`, 这个里面放着所有的插件，为了不每次增减插件都要手动修改代码，我们可能会想到用扫描的方式去动态获知 `org.example.plugins` 到底有多少 class, 当然应用场景很有很多

# 思路

在一开始的我们为了上传文件和下载文件这种需求，请求会在程序运行的时候去获取当前项目运行的父路径是什么，比如下面的代码`
使用Class类的getResource("").getPath()获取当前.class文件所在的路径`, 或者使用 `File` 来实现

```java
//实例化一个File对象。参数不同时，获取的最终结果也不同, 这里可以将 path 替换为要扫描的包路劲 例如 org/example
String path = "";

File directory = new File(path); 
//获取标准路径。该方法需要放置在try/catch块中，或声明抛出异常
directory.getCanonicalPath();
//获取绝对路径
directory.getAbsolutePath();
```

其中传入指定路径

```java
Enumeration<URL> resources = Thread.currentThread().getContextClassLoader().getResources("org/example");

while (resources.hasMoreElements()) {
  URL url = resources.nextElement();
  System.out.println(url.toString());
}

```

输出为

```


```


# 一些小功能

通过上面的代码，我们可以大概知道使用 `File` 遍历方式可以简单实现一部分包扫描，那我们定义个扫描器应该有的功能和特定吧

1. 可以根据指定的包进行扫描
2. 可以排除一些类或者包名
3. 可以过滤一些包或者类

关于过滤可以使用 `Java8` 的 `Predicate` 来实现，


# 简要设计

```java
public class ClassScanner {

    public ClassScanner(String basePackage, boolean recursive, Predicate<String> packagePredicate, Predicate<Class> classPredicate) {
    }

	public Set<Class<?>> doSacnAllClasses() {
        return null;
    }

}
```
 



# 完整代码

```java

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.net.JarURLConnection;
import java.net.URL;
import java.net.URLDecoder;
import java.util.Enumeration;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.regex.Pattern;

/**
 * class 扫描器
 *
 * @author 张瑀楠 zyndev@gmail.com
 * @version 1.0
 * @date 2017/12/22 11:06
 */
public class ClassScanner {



  // 是否包括内部类
  private boolean excludeInner = true;
  private boolean checkInOrEx = true;
  // 根据类名过滤
  private List<String> classFilters = null;

  public ClassScanner() {
  }

  public ClassScanner(Boolean excludeInner, Boolean checkInOrEx, List<String> classFilters) {
    this.excludeInner = excludeInner;
    this.checkInOrEx = checkInOrEx;
    this.classFilters = classFilters;
  }

  public boolean isExcludeInner() {
    return excludeInner;
  }

  public void setExcludeInner(boolean excludeInner) {
    this.excludeInner = excludeInner;
  }

  public boolean isCheckInOrEx() {
    return checkInOrEx;
  }

  public void setCheckInOrEx(boolean checkInOrEx) {
    this.checkInOrEx = checkInOrEx;
  }

  public List<String> getClassFilters() {
    return classFilters;
  }

  public void setClassFilters(List<String> classFilters) {
    this.classFilters = classFilters;
  }

  /**
   * 获取包中的所有类
   *
   * @param basePackage
   * @param recursive
   * @return
   * @throws IOException
   * @throws ClassNotFoundException
   */
  public Set<Class<?>> getPackageAllClasses(String basePackage, boolean recursive)
    throws IOException, ClassNotFoundException {
    // 使用LinkedHashSet来存放扫描到的类
    Set<Class<?>> classes = new LinkedHashSet<Class<?>>();
    String packageName = basePackage;
    // 如果最后一个字符是“.”，则去掉
    if (packageName.endsWith(".")) {
      packageName = packageName.substring(0, packageName.lastIndexOf('.'));
    }
    // 将包名中的“.”换成系统文件夹的“/”
    String package2Path = packageName.replace('.', '/');
    // 使用当前线程来加载文件夹
    Enumeration<URL> dirs = Thread.currentThread().getContextClassLoader().getResources(package2Path);
    while (dirs.hasMoreElements()) {
      URL url = dirs.nextElement();
      // 获取URL协议
      String protocol = url.getProtocol();
      if ("file".equals(protocol)) {
        String filePath = URLDecoder.decode(url.getFile(), "UTF-8");
        // 扫描文件夹中的包和类
        doScanPackageClassesByFile(classes, packageName, filePath, recursive);
      } else if ("jar".equals(protocol)) {
        // 扫描jar包中的包和类
        doScanPackageClassesByJar(packageName, url, recursive, classes);
      }
    }
    return classes;

  }

  /**
   * 在jar包中扫描包和类
   *
   * @param basePackage 包名
   * @param url         类路径
   * @param recursive   是否递归
   * @param classes     传引用，返回的结果
   * @throws IOException
   * @throws ClassNotFoundException
   */
  private void doScanPackageClassesByJar(String basePackage, URL url, final boolean recursive, Set<Class<?>> classes)
    throws IOException, ClassNotFoundException {
    // 包名
    String packageName = basePackage;
    // 获取文件路径
    String package2Path = packageName.replace('.', '/');
    // 转为jar包
    JarFile jar = ((JarURLConnection) url.openConnection()).getJarFile();
    // 遍历jar包中的元素
    Enumeration<JarEntry> entries = jar.entries();
    while (entries.hasMoreElements()) {
      JarEntry entry = entries.nextElement();
      String name = entry.getName();
      // 如果路径不一致，或者是目录，则继续
      if (!name.startsWith(package2Path) || entry.isDirectory()) {
        continue;
      }
      // 判断是否递归搜索子包
      if (!recursive && name.lastIndexOf('/') != package2Path.length()) {
        continue;
      }
      // 判断是否过滤 inner class
      if (this.excludeInner && name.indexOf('$') != -1) {
        continue;
      }
      String classSimpleName = name.substring(name.lastIndexOf('/') + 1);
      // 判定是否符合过滤条件
      if (this.filterClassName(classSimpleName)) {
        String className = name.replace('/', '.');
        className = className.substring(0, className.length() - 6);
        // 用当前线程的类加载器加载类
        classes.add(Thread.currentThread().getContextClassLoader().loadClass(className));
      }
    }
  }

  /**
   * 在文件夹中扫描包和类
   *
   * @param classes
   * @param packageName
   * @param packagePath
   * @param recursive
   * @throws ClassNotFoundException
   */
  private void doScanPackageClassesByFile(Set<Class<?>> classes, String packageName, String packagePath,
    boolean recursive) throws ClassNotFoundException {
    // 转为文件
    File dir = new File(packagePath);
    if (!dir.exists() || !dir.isDirectory()) {
      return;
    }
    final boolean fileRecursive = recursive;
    // 列出文件，进行过滤
    File[] dirfiles = dir.listFiles(new FileFilter() {
      // 自定义文件过滤规则
      @Override
      public boolean accept(File file) {
        if (file.isDirectory()) {
          return fileRecursive;
        }
        String filename = file.getName();
        if (excludeInner && filename.indexOf('$') != -1) {
          return false;
        }
        return filterClassName(filename);
      }
    });
    for (File file : dirfiles) {
      if (file.isDirectory()) {
        // 如果是目录，则递归
        doScanPackageClassesByFile(classes, packageName + "." + file.getName(), file.getAbsolutePath(), recursive);
      } else {
        // 用当前类加载器加载
        String className = file.getName().substring(0, file.getName().length() - 6);
        classes.add(Thread.currentThread().getContextClassLoader().loadClass(packageName + '.' + className));
      }
    }
  }

  /**
   * 过滤类文件
   *
   * @param className
   * @return
   */
  private boolean filterClassName(String className) {
    // 文件后缀为class
    if (!className.endsWith(".class")) {
      return false;
    }
    // 没有类过滤规则
    if (null == this.classFilters || this.classFilters.isEmpty()) {
      return true;
    }
    String tmpName = className.substring(0, className.length() - 6);
    boolean flag = false;
    for (String str : classFilters) {
      String tmpreg = "^" + str.replace("*", ".*") + "$";
      Pattern p = Pattern.compile(tmpreg);
      if (p.matcher(tmpName).find()) {
        flag = true;
        break;
      }
    }
    return (checkInOrEx && flag) || (!checkInOrEx && !flag);
  }
}



```