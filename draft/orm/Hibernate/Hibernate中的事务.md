――――――――――――――――――――――――――――
一,Hibernate中事务的处理	|
――――――――――――――――――――――――――――
	事务:逻辑上的一组操作,要么全都成功.要么全部都失败.回滚!
		> 原子性	-- 事务的一组操作,不可分割
		> 持久性	-- 一旦事务结束,数据就永久的保存到数据库
		> 一致性	-- 事务的执行前后,数据的完整性保持一致
		> 隔离性	-- 一个事务在执行的过程中,不应该受到其他事务的干扰

		如果不考虑事物的隔离性.会引发五大类的一些安全性的问题

		读取相关的问题:
			1,脏读			--> 一个事务读到另一个事务未提交的数据
			2,不可重复读	--> 一个事务读到另一个事务已经提交的数据(update),导致查询结果不一致
			3,虚读			--> 一个事务读到另一个事务已经提交的数据(insert),导致查询结果不一致
		写入相关的问题:
			1,丢失更新
				*　两个线程同时开启事务对一个数据进行修改.当A线程修改后,执行了commit,但是B线程执行了rollback或者commit.那么就B线程就把A线程的更新直接给覆盖掉了
				
		-------------	
		事务的隔离级别
			* 读未提交:以上三种问题都有可能会发生
			* 读已提交:避免脏读,2和3有可能发生
			* 重复读  :避免脏读和重复读,但3有可能发生
			* 串行化  :可以避免所有问题,但是效率最低
	> 可以在核心的配置文件中配置事务的隔离级别
	<property name="connection.isolation">2</property>
	关于事务的隔离级别
	读未提交			1	0001	(脏读,最可怕)
	读已提交			2	0010
	可重复读			4	0100	(默认设置)
	串行化(不可并发)	8	1000
	这个东西可以在hibernate.cfg.xml中进行配置
		>  如果你需要多个级别同时存在.那就按照二进制的规则来!
	也可以在mysql的配置文件中进行修改!
	这东西只在事务并发的时候有用！没并发就没用了

――――――――――――――――――――――――――――
一,Hibernate中丢失更新的问题|
――――――――――――――――――――――――――――
	Hibernate 的悲观锁和乐观锁来解决丢失更新

	使用悲观锁解决丢失更新的问题
		> 在发送SQL语句的时候加上一个 for update(排它锁)
		session.get(Class clazz,"10028",LockMode.UPCRADE );//这种查询方式就是一个排他锁
			* 使用这种方式查询,那么在查询的时候就会自动的加上排他锁.其他事务就必须等到这个事务的结束.
			* 这种方式,效率不高.只有等待你操作完了,那么其他的事务才能操作这个


	使用乐观锁解决丢失更新的问题
		> 可以在实体类中加一个 Iteger 类型的字段,名称随意!version
		那么在映射文件中就要配置:
		<version name="version"/>
		session.get(Class clazz,"10076");
		
	
	* 当A线程访问数据的时候,A线程就会得到一随机个版本号.跟数据库一致.当A线程执行了commit的时候会先比对版本号,如果一致就允许执行.而且修改版本号
	* 当B线程也访问的时候,也会得到一个随机的版本号,B线程执行的时候如果检查版本号出现问题,那么就会拒绝执行rollback或者commit

