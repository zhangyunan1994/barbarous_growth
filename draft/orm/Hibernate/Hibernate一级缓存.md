
――――――――――――――――――――――――――――
一,Hiernate一级缓存			|
――――――――――――――――――――――――――――
	> 缓存:这东西顾名思义,其实就是把数据源(数据库)中的数据.放到缓存(内存中的一块儿空间)中,当我们再次使用的时候,可以直接从内存中获取,不需要再次的访问数据源
	> Hibernate的缓存,是一种优化手段,此框架中分为两个缓存
		一级缓存 --> Session级别的缓存
			* 一级缓存,与Session的生命周期一致
			* 默认自带,还不能卸载.必须就是使用的
		二级缓存 --> SessionFactoy级别的缓存
			* ... ....可以在多个Session中共享数据
			* 默认是不开启的,需要配置才能使用

――――――――――――――――――――――――――――
二,理解,Session缓存			|
――――――――――――――――――――――――――――
	* 在Session接口的实现中,包含一些了的java集合.这些'Java集合构成了Session缓存'.只要Session实例没有结束生命周期
	  存放在它缓存中的对象也不会结束生命周期
	* 当Session的save()方法持久化一个对象的时候,该对象被载入缓存!以后即使程序中不再引用该对象!只要缓存不清空,该对象任然处于生命周期中!
	  当试图:set(),load().对象的时候,会先判断缓存中是否存在该对象.有则返回.此时不查询数据库,如果没.再查询数据库!
	* Session能够在某些时间点,按照缓存中对象的变化,来执行相关的SQL语句,来同步更新数据库,这一过程,被称为刷出缓存:flush
	* 默认情况下,Session在一下时间点刷出缓存
		1,当应用程序调用Transaction的commit().提交事务的时候,该方法先刷出缓存(session.flush()).然后再向数据库提交事务
		2,当应用程序执行一些查询操作的时候,如果缓存中持久化对象的属性以及发生了变化.会先刷出缓存.以保证查询的结果能够反应持久化对象的最新状态
		3,调用Session的flush方法.
	

	当Session调用get从数据库中获取数据的时候,还会把对象存在Session的以及缓存中

――――――――――――――――――――――――――――
三,快照区,Session缓存		|
――――――――――――――――――――――――――――
	* 持久化对象,能够自动更新数据库,完全就是依赖了这个快照区
	简单理解:
		当对象从缓存中拿出来的时候,缓存会给它'拍个照',记录一下!当事务结束的时候,会拿这个对象跟跟快照区对比.看看是不是拿出来以后数据有过更新!如果有,那么就执行update修改!
	
	actionQueue			['活动队列']
		* 手动调save,update里面才有数据
	persistenceContext	['']
		* 内部其实是有一个 Map 集合的!也就是说我们的一级缓存其实就是由一个 Map 构成的
		* key:就是我们的一级缓存区
		* value:快照区
	

	> key,和value都是保存数据的!value,就是对象从数据库从取出来的初识数据!key,就是给你的对象!你如果对key进行了数据修改.那么框架经过key和value一对比发现数据不一样.就执行了 update语句

	['总结']
	当使用get/load的时候,会向缓存区和快照区都存一份.
	事务提交的时候,会判断缓存区跟快照区的数据是否相同.不相同就执行update方法

――――――――――――――――――――――――――――
四,管理,Session缓存			|
――――――――――――――――――――――――――――
	* 一级缓存是与Session的生命周期相关的,Session生命周期结束.一级缓存也就销毁了
	
	['管理Session缓存的方法']
	flush();			//刷出缓存,把所有对象都刷新到数据库!数据库没有记录就创建,跟数据库记录不一样就更改(commit之前,框架会默认的调用这个方法)
	clear();			//清空一级缓存中的数据
	refresh(Object);	//把指定对象的快照区域的数据,覆盖一级缓存区域的数据
		* 得去这么理解 ―――― '恢复出厂状态'!你从数据库里面得到对象后,不管你这么修改.只要还在session的管理中.调用了这个方法!就不更新了!而且你对属性的修改.就没用了.
	evict(Object);		//从一级缓存中清空指定的对象

――――――――――――――――――――――――――――
五,刷出时机,Session缓存		|
―――――――――――――――――――――――――――
	清理Session的缓存(设置缓存的flush模式)

	session.setFlushMode(FlushMode.AUTO);

	清理缓存模式			session查询方法		事务的提交commit()		session的flush()
	FlushMode.AUTO(默认)	刷出(某些查询)		刷出					刷出
	FlushMode.COMMIT		不刷出				刷出					刷出
	FlushMode.ALWAYS		刷出(所有查询)		刷出					刷出
	FlushMode.MANUAL		不刷出				不刷出					刷出


	严格程度:MANUAL --> COMMIT --> AUTO -->ALWAYS

	了解一下就行了,一般不用做修改.默认值就好

――――――――――――――――――――――――――――
六,旧笔记					|
―――――――――――――――――――――――――――

这东西吧,得这么去理解
从Session开始说!Session是有个缓存,当第一次从数据库中获取对象之后,这个对象还在Session里面缓存着
当你下次还要使用这个对象的时候,Session就从缓存中把这个对象给你！如果缓存没找到,就连接数据库进行查找!
。。那么问题来了,这个机制非常的不错！但是,Session之间的缓存不能同步!如果多个请求都在请求同一个对象的话。。每个请求虽然都有自己的Session缓存!但是每个Session都要去查一遍数据库!
我们得找个办法,让这些Session缓存的东西！再次缓存一遍!不管是谁,访问!不管是哪个Session,只要是这个数据,都不用访问数据库！

一级缓存,最大的作用就是管理对象!其实不是提高性能!(Session的那个缓存就是一级缓存)
二级缓存,就是提高效率的


集合缓存
	> 类中的成员属性是集合!也可以对集合进行缓存！集合缓存,缓存的就是id,真正的类还是要去类缓存中找
类缓存
	> 只是做了类缓存的配置,那么类中的集合其实是没有缓存的!没有没有缓存类中的集合,你在使用集合的时候,还是回去数据库中查找
-----------------------------------------结构演示
Session1	Session2	Session3...
  |		   |                |
		  缓存
		   |
		 数据库
----------------------------------------
二级缓存机制默认是没有开启的！因为不是任何程序都适用缓存,例如:财务,等一些敏感的数据!就不能被缓存!

开启二级缓存:类
1,在主配置文件(hibernate.cfg.xml)中添加如下标签
<property name="cache.region.factory_class">org.hibernate.cache.ehcache.EhCacheRegionFactory</property> 
	> 表示已经开启了缓存,但是还没指定哪些类要缓存
	> 这个更高级的缓存,有自己的一个配置文件...懒得写了!会在本地生成缓存文件!这东西吧,自己去百度吧我的天！累死了今天！
	* 这东西吧,可以换成其他的第三方缓存类!
<property name="cache.use_query_cache">true</property>
	> 这东西,表示查询!也缓存!不仅仅是get/load方法获取的对象缓存!QHL查询的出来的也会缓存
	> 这样的设置还不够,需要在查询的时候使用到Query的setCacheable(true);双管齐下!才奏效
2,导入jar包
ehcache文件夹下的(自己找)
	> ehcache-core-2.4.3.jar
	> hibernate-ehcache-5.0.5.Final.jar
	> slf4j-api-1.6.1.jar
3,指定要缓存的类
	> 第一办法就是在主配置文件中指出
		> <class-cache usage="read-only" class="指定类的全路径"/>
		* usage:有几个变量可以自己选择.只读/可读...
		* 这个东西有问题,妈的,会报错！坑死爹了！先别用,用下面种
	> 第二种办法就是在'需要被缓存的类的配置文件'中写出
		> 在class标签下添加这个标签:<cache usage="read-only"/>
		* 表示要缓存,缓存的方式就是:只读
		* 测试成功, 没问题！可以用这种方式
开启二级缓存:集合
满足上面条件后..添加下面的方法之一
1,在主配置文件中声明
	> <collection-cache usage="read-only" collection="com.kevin.domain.Department.employees"/> 
	* coolection:要写明是哪个类?的哪个属性(集合)需要被缓存
	* 尼玛,这个也有问题!5.0.5版本会报错!
2,在类的配置文件中声明
	

------------------------------注意
1,不管是一级缓存,还是二级缓存,都是在使用OID的方式的获取对象的时候才有效!get/load方法的就可以!
2,Query.list()默认不会使用缓存,就算你的HQL语句是:from xx where id=?也不行！

-----------------------------非要让HQL查询的数据放到缓存
Iterator<xxx> it = session.createQuert("from xxx where id > 10").iterate();
> 这个方法就会使用缓存,但是!因为这个方法是先查询所有符合条件的id集合,再一个一个的按id查找数据!就能上缓存了
但是这个方法会有N+1次的差问题,效率提高很有限!不常用!

------------------------------更为专业的查询缓存
session1.createQuery("").setCacheable(true).list();
	> setCacheable,就是是否设置缓存!
	> 那么每次使用查询都带有true,而且,每次查询的条件都是一样的！因为它保存的就是查询条件
	> 默认,这个东西是没开启的！需要主配置文件,进行配置
	> <property name="cache.use_query_cache">true</property>
	> 配置存在且值为true,同时设置setCacheable(true);查询就会被缓存！

总结---------------
集合的缓存	自己看
类的缓存	自己看
查询的缓存	自己看

注意---------------
update ---> delete   -----> 都不会通知Session缓存
	> 就是你把对象缓存到Session后,又执行了修改语句!数据库中已经改变!但是Session没有执行refresh就不会改变!
那么二级缓存呢?
	如果二级缓存中的数据,在缓存的时候,执行了update,delete等语句!那么缓存中的数据就会失效!下次使用的时候,就会重新到数据库中去获取
	那就是没影响的！





