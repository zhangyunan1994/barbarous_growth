――――――――――――――――――――――――――――
一,Hibernat持久化类状态		|
――――――――――――――――――――――――――――
	> 持久化类:就是一个实体类,与数据库表建立了映射
	> Hibernate把持久化类分为三种状态
	★ 瞬时状态 transient 
		*　不存在持久化OID,尚未与Hbernate的Session关联.就被认为是瞬时状态!失去引用,就会被JVM当作垃圾回收!
		* '无持久化标识OID,与Session未关联'
	★ 持久状态 persistent
		* 存在持久化标识OID,与倒档器Session有关联.且相关联的Session没有关闭!且,事务未提交
		* '存在持久化标识OID,与Session关联'
		['结论']
		* 这种状态的持久化类,有自动更新数据库的能力.原因就是'依赖了Hibernate的一级缓存'
	★ 托管粘贴 detached
		* 存在持久化标识OID,但没有与当前Session关联,托管状态改变Hibernate不能检测到
		* '存在持久化标识OID,未与Session关联'
	
――――――――――――――――――――――――――――
二,操作持久化对象的方法		|
――――――――――――――――――――――――――――
	save(Object obj);			//把一个瞬时对象转换为持久化对象
		* 把瞬时对象加入到session缓存中,使它进入持久化状态!
		* 根据对应的映射文件,指定的标识符生成器.为持久化对象分配唯一的IOD
		  在使用代理主键的情况下,setId方法为瞬时对象设置OID是无效的
		* 计划执行一条insert语句,把对象当前的属性值组装到insert语句中
	
	Hiberante通过持久化对象的OID,来维持它数据库相关记录的对应信息.当对象处于持久化状态的时候,不允许程序随意修改它的ID!

	update(Object obj);
		* 把托管对象,转换为持久化对象
	saveOrUpdate(Object obj);
		* 保存或者更新指定的对象.如果你是瞬的!
	
	

	