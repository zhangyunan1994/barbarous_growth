											ArrayList al = new ArrayList();
								Collection 接口的所有方法 ―― 能应用到 List 以及 Set 的所有子类中
al.add(x);//添加一个x元素到al容器里面.
al.addAll(x);//将x容器里面的所有元素都添加到al容器中.
al.clear();//清空al容器里面的所有.
al.contains(x);//查询al容器里面是否有x元素.
al.containsAll(x);//查询al容器里面是否包含x容器中的所有元素.
al.equals(x);//比较al是不是与x对象相等.
al.hashCode();//获得al容器的哈希码值.
al.isEmpty();//判断al是否为空容器.
al.iterator();//获得al容器的迭代器。用于对al容器里面的元素进行迭代.
al.remove(x);//从容器al中删除x这个元素.
al.removeAll(x);//从容器al中删除x容器中所有的相同元素.――去交集
al.retainAll(x);//al容器里面只保留与x容器里面相同的元素.――取交集
al.size();//得到al容器的长度.
al.toArray();//把al集合变数组。返回是的Object类型。
al.toArray(arr[]);//把al集合变成数组。返回的是arr数组类型。
	指定类型的数组arr[].长度小于了集合的size();那么该方法内部会创建一个新的数组长度为集合的size();
	如果长度大于了集合的size();不会创建新数组。那么空白部分用null填充。
	所以创建一个长度相等的数组比较妥当。消耗资源比较小。
该方法存在的意义主要是。限制对元素的操作。例如――不允许进行增删操作
----------------------------------------------------------------------
								List 接口的特有方法 ―― 能应用到 ArrayList 以及 LinkedList
List 里面的元素是有序的。元素可以重复。因为该集合有索引。
al.add(y,x);//在角标为y的位置。插入x元素.
al.addAll();//
al.addAll();//
al.get(x);//获取角标为X的元素.
al.indexOf(x);//返回x在al容器中第一次出现的位置。如果没找到则返回 -1.
al.lastIndexOf(x);//返回x在al容器中最后一次出现的位置。如果没有找到则返回 -1.
al.set(y,x);//用x元素替换掉al容器中角标为y的.			
al.subList(x,y);//返回al容器中x位置到y位置的所有元素.不包含y.
List 集合，特有的迭代器 ListIterator 是 Iterator 的子接口。
	在迭代时，不可以通过集合对象的方法操作集合中的元素。会发生异常！在迭代时只能用迭代器的方法操作元素！
	但是， Iterator  的方法是有限的。只能对元素进行判断。取出，删除等操作！
	如果需要其他的操作。如，添加，修改等。就需要使用其子接口 ListIterator.
	该接口只能通过 List 集合的 listIterator方法获取。
	ListIterator 的出现。实现了可以让 List 集合在遍历的时候实现增删改查！
ListIterator //列表迭代器方法
	hasNext();//判断是否还有下一个元素存在容器里面
	next();//返回下一个元素.
	remove();//删除循环到当前的元素.
	hasPrevious();//逆向遍历列表。判断是否还有前一个元素在容器.
凡是可以操作角标的方法都是。 List 的特有方法！List可以用for循环配合get();直接取值！

List '子类' -------------------------------------------------------------------------

List  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>	ArrayList
		底层的数据结构使用的是数组结构。特点：查询速度很快，但是增删稍慢。此外它线程不同步
		默认容器长度是10.如果元素超出，那么以50%长度的规模进行新建容器。再复制原来数组的元素。
List  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>	LinkedList
		底层的数据结构使用的是链表结构。特点：增删速度很快，但是查询稍慢。 
LinkedList '特有方法'
al.addFirst();//在容器最前面添加一个元素.
al.addLast();//在容器的最后添加一个元素.
al.getFirst();//获取容器的第一个元素.
		特点：获取元素，但不删除元素
al.getLast();//获取容器的最后一个元素.	如果元素不存在，就会抛出“没有这个元素”异常
		特点：获取元素，但不删除元素
al.removeFirst();//删除容器的第一个元素.	如果元素不存在，就会抛出“没有这个元素”异常
		特点：获取元素，但是删除元素
al.removeLast();//删除容器的最后一个元素.	如果元素不存在，就会抛出“没有这个元素”异常
		特点：获取元素，但是删除元素
		/*------------------新版JDK1.6以后，以下方法可以替换以上方法--------------------*/
al.offerFirst();//在容器最前面添加一个元素.
al.offerLast();//在容器的最后添加一个元素.
al.peekFirst();//获取容器的第一个元素.
		特点：获取元素，但不删除元素
al.peekLast();//获取容器的最后一个元素.	如果元素不存在，就会抛出“没有这个元素”异常
		特点：获取元素，但不删除元素
al.pollFirst();//删除容器的第一个元素.	如果元素不存在,就返回 ―― null.
		特点：获取元素，但是删除元素
al.pollLast();//删除容器的最后一个元素.如果元素不存在,就返回 ―― null.
 		特点：获取元素，但是删除元素

List  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>	Vector
		底层是数组数据结构。 Vector 是元老级别人物。它是最先的容器。是老祖宗。此外它线程同步。它的查询和增删都慢。
		默认容器长度是10.如果元素超出，那么以100%长度的规模进行新建容器。再复制原来数组的元素。
		它有自己的特有取出方式――――枚举  ：Enumeration en = v.elements();
		其实枚举跟迭代是一样的！枚举的名称跟方法的名称都比较长。后来被迭代器取代了。枚举就算是被淘汰了！