反射技术的出现，提高了程序的扩展性。
当应用程序后期出现的数据不确定的时候，可以通过配置文件这种形式来完成数据的存储！
反射技术
	|--可以'动态的'获取类，以及类中的成员。并可以调用其该类的成员。
以前是有什么类就 new 什么对象，现在反射是。没有类，给什么类。就 new 什么对象！以前是先有类。
	在反射技术中'最重要的就是要先获取到那个对应的类'。如何获取呢？
无论 new 什么对象。都需要先获取字节码文件。
其实JAVA已经有了对字节码文件描述的类。就是 ―― Class
												|--秒速字节码文件的类 .class 
获取字节码文件对象的方法：
方式一：
	用 Object 方法中的getClass();来获取当前对象运行时类的 Class 对象！
Class c = Object.getClass();
	|--已知对象通过getClass();方法。可以获取到这个类对象。
但是，这个方法在反射中却不合适。因为反射技术是不明确具体类的。
方式二：
	所有的数据类型都有自己对应的 Class 对象。表示方式很简单。
每一个数据类型，都有一个默认的静态属性。 .class 用该属性，就可以获取到字节码文件。
Class c = 数据.class 
	|--获取已知的class文件。来获取它的对象。
这种方式也要明确这个具体类。
方式三：   '常用'
	在 Class 类中的有一个forName();方法。可以通过名称就直接获取到 Class 对象。
Class.forName(类名);
	|--这个方法，会在classpath环境变量的目录下去寻找这个文件。然后直接加载到内存，并封装成一个 Class 对象！
	|--'切记'。类名一定要写全！包名，类名等。体系要写完全。
----------------------------------------------------用反射'创建对象'
Class c = forName("指定类名");
c.newInstance();
	|--创建了一个指定类的新对象。使用的默认的空参数的构造函数。
	如果该类没有默认的空构造函数那么会抛出异常！实例化失败什么的忘记了。
	所有。一般被反射的类。一般都有空参数的构造函数。方便与反射使用。
	但是类中不一定都有空参数的构造函数，那么在获取对象之前，可以先获取指定的构造函数。再通过指定的构造函数进行实例化！见下方法
Constructor cons = c.getConstructor(String.class,int.class);//传递参数要注意
	|--通过class文件获取指定的构造函数(被 public 修饰的)。例如：带两个参数。一个 String 类型，一个 int 类型。返回的是一个'构造器'对象！
		|--JAVA的万物皆对象，就算是构造器。也是一个对象。你怕吗？
Object obj = cons.newInstance("Kevin",21);
	|--用指定的构造函数创建了一个实例。返回的是一个 Object 。
----------------------------------------------------用反射'获取字段(成员属性)'
Field f = c.getField("字段名称");//该字段必须是公有权限的。否则抛异常
	|--获取类中指定字段名称'并且修饰符必须是public'的变量。返回的也是字段的对象 Field(万物皆对象，再次提现。类成员变量也是对象);
Field f = c.getDeclaredField("字段名称");//能获取各种权限的的字段。
	|--获取类中指定字段名称的变量。返回的也是字段的对象 Field(万物皆对象，再次提现。类成员变量也是对象);
	f.setAccessible(true);//设置字段的属性为可被访问。如果进行赋值操作的时候该字段是 private 那么必须要有这一步。反之可跳过。这个叫做暴力访问。
	f.set(Object,value);//给指定对象的这个字段进行赋值操作。
Field[] f = c.getFields();//返回的是一个 Field 的数组。规则同上。
Field[] f = c.stsgetDeclaredFields()//返回的是一个 Field 数组。规则同上。
----------------------------------------------------用反射'获取方法'
其实方法的获取形式，规则上差不多跟字段的获取是一样的！
Method m = c.getMethod("方法名称",null);//null。表示的是该方法的参数列表。而这个参数也是 .class 类型表示的！如果没有就写 null .该方法必须是公有权限的。否则抛异常
	|--获取类中指定名称'并且修饰符必须是public'的方法。返回的也是方法的对象 Field(万物皆对象，再次提现。类成员方法也是对象);
Method[] m = c.getMethods();//返回的是所有公共方法。包括从父类中继承的。(不包含本类的 public 以下的方法。包括父类的public 方法)
	|--获取的是所有的方法。不包括继承的。
	Object obj = m.invoke(Object,value)//指定对象去调用这个方法。value代表方法的形参。如果没有可以写null。
	'静态方法的调用' 如果该方法是静态的那么。可以不用指定对象，直接输入 null 即可！
Method[] m = c.getMethods();//获取的所有的public 修饰的方法，不包括继承来的方法。
Method[] m = c.getDeclaredMethods() //返回的是所有方法(所有权限修饰的方法)，不包括继承的方法











	